#' Calculate Normalized Clustering Coefficient for Single or List of Matrices
#'
#' @title Normalized Clustering Coefficient Calculation
#' @description Computes the normalized clustering coefficient for a given matrix.
#' The normalized clustering coefficient is calculated by dividing the global clustering coefficient of the input matrix (using `global_clustering_coefficient_wei()`)
#' by the mean global clustering coefficient of a set of random matrices with a matched strength distribution. The random matrices can be generated by `generateRewiredMatrices()`.
#' Accepts either a numeric matrix or a list containing a matrix and array of random matrices already generated. If no array of randomized matrices is provided and the input is a matrix, the function generates one.
#' If the global clustering coefficient of the input is 0, the function returns 0 to avoid division by zero errors.
#' The list elements must not be named.
#' @param mat_list A square matrix or a list containing a matrix and an optional 3D array of randomized matrices for comparison.
#' If provided as a list, the first element should be the matrix, and the second element (if present) should be the array of randomized matrices.
#' If a single matrix is provided and no array of randomized matrices is given, a set of randomized matrices is generated.
#' @param rand_array An optional 3D array of randomized matrices for comparison if the input is a single matrix. If NULL and the input is a matrix,
#' @param validate Whether to validate the input matrix.
#' a set of randomized matrices is generated. This parameter is ignored if the input is a list.
#' @return The normalized clustering coefficient, computed as the ratio of the clustering coefficient of the input matrix to the average clustering
#' coefficient of the randomized matrices. Returns 0 if the global clustering coefficient of the input is 0 to prevent division by zero errors.
#' @examples
#' # For a single matrix input
#' W <- matrix(c(0, 2, 1, 0, 2, 0, 3, 5, 1, 3, 0, 6, 0, 5, 6, 0), nrow = 4, byrow = TRUE)
#' norm_clust_coeff <- normalised_clustering_coefficient(W)
#' rand_matrices <- generateRewiredMatrices(W, 100)
#' rand_matrices <- abind::abind(rand_matrices, along = 3)
#' mat_list <- list(W, rand_matrices)
#' norm_clust_coeff <- normalised_clustering_coefficient(mat_list)
#' # Can also be called with the format:
#' norm_clust_coeff <- normalised_clustering_coefficient(W, rand_matrices)
#' @importFrom abind abind
#' @export


normalised_clustering_coefficient <- function(mat_list, rand_array = NULL, validate = TRUE) {

  if(is.matrix(mat_list)){
    if(validate){validate_matrix(mat_list)}
    if(network_density(mat_list, FALSE)==1){
      warning("Network density is equal to 1. Network cannot be rewired while maintaining degree distribution\n
              This may make results incorrect.")
    }
    # If the global clustering coefficient is 0 then the normalised clustering coefficient will be 0 and math errors will be created by 0 division.
    if(global_clustering_coefficient_wei(mat_list, FALSE)==0){
      return(0)
    }
    # Generate randomized matrices if not provided
    if (is.null(rand_array)) {
      rand_array <- generateRewiredMatrices(mat_list, 100) %>%
        abind::abind(along = 3)
    }
    # Validate that rand_array is indeed an array
    if (!is.array(rand_array)) {
      stop("Random array specified is not in the form of an array")
    }
    # Calculate the average clustering coefficient for the random array
    rand_c <- mean(apply(rand_array, MARGIN = 3, FUN = function(x) global_clustering_coefficient_wei(x, FALSE)))
    # Calculate the clustering coefficient for the input matrix
    c <- global_clustering_coefficient_wei(mat_list, FALSE)
    # Normalize the clustering coefficient by the random array's average
    norm_c <- c / rand_c
    return(norm_c)
  }
  if(is.list(mat_list)){
    if(network_density(mat_list[[1]])==1){
      warning("Network density is equal to 1. Network cannot be rewired while maintaining degree distribution\n
              This may make results incorrect.")
    }
    # If the global clustering coefficient is 0 then the normalised clustering coefficient will be 0 and mat_list[[1]]h errors will be created by 0 division.
    if(global_clustering_coefficient_wei(mat_list[[1]],FALSE)==0){
      return(0)
    }
    # Validate that rand_array is indeed an array
    if (!is.array(mat_list[[2]])) {
      stop("Random array specified is not in the form of an array")
    }
    # Calculate the average clustering coefficient for the random array
    rand_c <- mean(apply(mat_list[[2]], MARGIN = 3, FUN = function(x) global_clustering_coefficient_wei(x, FALSE)))
    # Calculate the clustering coefficient for the input matrix
    c <- global_clustering_coefficient_wei(mat_list[[1]], FALSE)
    # Normalize the clustering coefficient by the random array's average
    norm_c <- c / rand_c
    return(norm_c)
  }
}
