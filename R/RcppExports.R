# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @name floydWarshallRcpp
#' @title Floyd-Warshall Algorithm in R
#' @description This function implements the Floyd-Warshall algorithm using Rcpp for finding the shortest distances
#' between every pair of vertices in a given edge weighted directed Graph. It operates on a matrix representation of the graph.
#' @param inputMatrix A NumericMatrix representing the adjacency matrix of the graph where the element at the ith row
#' and jth column represents the weight of the edge from vertex i to vertex j. If there is no edge between vertex i and vertex j,
#' the value should be 0 for i != j.
#' @return A NumericMatrix where the element at the ith row and jth column represents the shortest distance from vertex i
#' to vertex j in the input graph.
#' @examples
#' W <- matrix(c(0, 2, 1, 0, 2, 0, 3, 5, 1, 3, 0, 6, 0, 5, 6, 0), nrow = 4, byrow = TRUE)
#' shortestPaths <- floydWarshallRcpp(W)
#' @export
NULL

floydWarshallRcpp <- function(inputMatrix) {
    .Call(`_NetAnalyseR_floydWarshallRcpp`, inputMatrix)
}

calculateBetweennessCentrality <- function(D, NP) {
    .Call(`_NetAnalyseR_calculateBetweennessCentrality`, D, NP)
}

dijkstraAllPairs <- function(matrix) {
    .Call(`_NetAnalyseR_dijkstraAllPairs`, matrix)
}

rewireTwoNetworksCpp <- function(originalMatrix, secondaryMatrix, initialIter) {
    .Call(`_NetAnalyseR_rewireTwoNetworksCpp`, originalMatrix, secondaryMatrix, initialIter)
}

#' @keywords internal
NULL

localClusteringCoefficientWei <- function(W_original) {
    .Call(`_NetAnalyseR_localClusteringCoefficientWei`, W_original)
}

#' @export
NULL

localEfficiencyWei <- function(W_original) {
    .Call(`_NetAnalyseR_localEfficiencyWei`, W_original)
}

#' Rewire a Network Matrix
#'
#' This function takes a network represented as an adjacency matrix and
#' performs a specified number of edge rewiring iterations to randomize the network.
#' It checks for network density and skips rewiring if the network is fully connected.
#' @name rewireNetworkCpp
#' @param R A numeric matrix representing the network's adjacency matrix.
#' @param initialIter int number of iterations for the rewiring process.
#' @param validate bool specifying whether to check the validity of the input matrix
#'
#' @return A rewired numeric matrix representing the network's adjacency matrix.
#' @export
rewireNetworkCpp <- function(R, initialIter = 2L, validate = TRUE) {
    .Call(`_NetAnalyseR_rewireNetworkCpp`, R, initialIter, validate)
}

#' Generate a Series of Rewired Matrices
#'
#' Rewires a matrix n times, performing 10 iterations each time.
#' Saves all random matrices generated as a list.
#' The output is in the format of a list. If manually using the output in normalised mesures
#' the output must be converted to an array with `abind::abind(matrix, along = 3)`
#' @name generateRewiredMatrices
#' @param initialMatrix A numeric matrix representing the initial network's adjacency matrix.
#' @param n The number of rewired matrices to generate.
#'
#' @return A list of 'n' rewired matrices.
#' @export
generateRewiredMatrices <- function(initialMatrix, n = 100L) {
    .Call(`_NetAnalyseR_generateRewiredMatrices`, initialMatrix, n)
}

